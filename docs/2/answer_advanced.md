# 総合演習の解答と解説

## 問題1.
### 解答例
```python
pi_approx = 3.14159265359
b = 0
k = -1
while abs(pi_approx - b) >= 1e-7:
    k += 1
    x = 4/(8*k+1)
    y = 2/(8*k+4)
    z = 1/(8*k+5)
    w = 1/(8*k+6)
    a = (x-y-z-w)/(16**k) 
    b += a
print(k)
print(b)
```

### 解説
予め $0$ で初期化した第 $n$ 項までの値を足したものに対応する変数(解答例だと`b`) を用意して起き、各ループで級数の中の項

$$
\frac{1}{16^k}\left(\frac{4}{8k+1}-\frac{2}{8k+4}-\frac{1}{8k+5}-\frac{1}{8k+6}\right)
$$

を足していけばOKです。各ループごとに和を最初から計算し直す必要はないことに注意しましょう。

### 背景
問題文にも書きましたが、BPP公式

$$
\pi=\sum_{k=0}^\infty \frac{1}{16^k}\left(\frac{4}{8k+1}-\frac{2}{8k+4}-\frac{1}{8k+5}-\frac{1}{8k+6}\right)
$$

収束速度や並列処理の容易性などからコンピュータでの円周率の数値計算に今でも使われています。特にスーパーコンピュータによる処理はいかに並列に問題を処理できるかということが性能に直結するので、各項をバラバラに計算して最後に足し合わせることができるBPP公式はスーパーコンピュータと相性が良いわけです。しかも級数は $16^{-k}$ の項がかかっているので非常に収束が高速です。

BPP公式の証明は[この辺](https://xn--w6q13e505b.jp/proof/bbp.html)を見てください。無限和と積分の順序交換[^1] さえ認めてあげると、高校数学の範囲の計算しかしないので理解はできると思います。

[^1]: ちゃんと正当化したい方は[優収束定理](https://ja.wikipedia.org/wiki/%E5%84%AA%E5%8F%8E%E6%9D%9F%E5%AE%9A%E7%90%86)などのキーワードで調べてみると良い。


## 問題2.
### 解答例
以下のコードだとループの数が多すぎて10秒くらいかかりますが正解できます。
```python
counter = 0
for x1 in range(101):
  for x2 in range(101):
    for y1 in range(101):
      for y2 in range(101):
        if (x1-x2)**2 + (y1-y2)**2 == 65:
          counter += 1
print(counter // 2) # 重複して数えた分を取り除く
```
そこで予め `for` ループで探す候補を削ると速くなります。
```python
counter = 0
diff = [(1, 8), (1, -8), (4, 7), (4, -7), (7, 4), (7, -4), (8, 1), (8, -1)]
for x1 in range(101):
  for y1 in range(101):
    for (dx, dy) in diff:
      x2 = x1 + dx
      y2 = y1 + dy
      if 0 <= x2 <= 100 and 0 <= y2 <= 100:
        counter += 1
print(counter)
```

### 解説
ループを削って効率的に探索できるかを見たくて問題にしました。しかし、

$$
65 = 1^2+ 8^2 = 4^2+7^2
$$

に注目すれば片方の座標 $(x,y)$ を決めればもう片方の座標の候補は $16$ 個しかないので候補を絞れます。さらに対称性などを使って考えるべきケースを減らしていけば実は手計算でも頑張ればできるので、以下のコードでも正解です。

```python
answer = 73672
print(answer)
```

### 背景
今回用いた $65$ という数字は

    2つの相異なる平方数の二乗和として2通り以上で表される最小の自然数
    
という性質をもつので答えが大きくなりやすいため、この数字を採用しました。これは $65=5\cdot 13$ という素因数分解ができることに由来しています。なぜなら $5,13$ は $4$で割って $1$ 余る素数のうち小さい方から $1$ 番目と $2$ 番目だからです。

[フェルマーの2平方和定理](https://manabitimes.jp/math/844)という定理は知っている方もいるかもしれませんが、正整数 $n$ が2つの $0$ も含めた平方数の和で表されるのは $n$ を素因数分解したときに $4$ で割って $3$ 余る素数の指数がすべての偶数であるとき、かつそのときに限るという事実があります。この定理よりさらに定量的な情報を調べているのが、**ヤコビの2平方和定理** というもので、その主張は以下で述べられます。なお、 $\mathbb{N},\mathbb{Z}$ はそれぞれ自然数全体、整数全体の集合です。

!!! Note "ヤコビの2平方和定理"

    正整数 $n\in\mathbb{N}$ に対して、

    $$
    r(n)=|\{(x,y)\in\mathbb{Z}\times\mathbb{Z}:x^2+y^2=n\}|
    $$

    とおく。さらに $p_1(n),p_3(n)$ でそれぞれ $n$ の素因数の中で $4$ で割って $1$ 余るもの、$3$ 余るものの総数、すなわち

    $$
    p_1(n)=|\{p\in\mathbb{N}:p\equiv 1(\mod 4),p \mbox{は} n の素因数\}|
    $$

    $$
    p_3(n)=|\{p\in\mathbb{N}:p\equiv 3(\mod 4),p \mbox{は} n の素因数\}|
    $$

    とおく。このとき、

    $$
    r(n)=4(p_1(n)-p_3(n))
    $$

    が成立する。

この定理をここで証明するのは難しいのでしませんが、通常は複素関数論の手法を用いて証明されます。また、その際に主要な道具立てとなるテータ関数は保形形式などのさらに進んだ数学とも関わりが深く、数学を進んで勉強したい方には一つのランドマークにはなるかもしれません。[^2]

[^2]: 一冊だけ証明の書いてある和書を挙げておくと [
エリアス・Ｍ.スタイン ラミ・シャカルチ (著)、 プリンストン解析学講義2 複素解析、 日本評論社](https://www.nippyo.co.jp/shop/book/5054.html) がおすすめです。数論ではなく複素解析の本です。

## 問題3.
### 解答例
```python
def solve(n):
  if n % 2 == 0:
    return 0
  elif n % 5 == 0:
    return 0

  R = 1
  for i in range(n):
    if R % n == 0:
      return i + 1
    R = 10 * R + 1

print(solve(n))
```

### 解説
この問題は少し数学的な考察を要するようにしてみました。次の定理に気づけるかどうかが鍵です。

!!! Note "定理"

    正整数 $n$ に対して、 ある $m$ が存在して $R_m$ が $n$ の倍数になるための必要十分条件は、$n$ が $2$ でも $5$ でも割り切れないことである。

??? "証明"

    必要性は自明である。

    十分性を示す。つまり、$n$ が $2$ でも $5$ でも割り切れないとして、ある $m$ が存在して $R_m$ が $n$ の倍数となることを示す。$R_1,\ldots,R_{n+1}$ の中で $1\leq i<j\leq n+1$ かつ $n$ での剰余が一致する、すなわち

    $$
    R_i\equiv R_j\mod n
    $$

    となるものをとる。このとき

    $$
    R_j-R_i=R_{j-i}\times 10^i
    $$

    であるが、左辺は $n$ の倍数であるので右辺もそうである。ところが $n$ は $2$ でも $5$ でも割り切れないので $10^i$ で割り切れることはなく、これは $R_{j-i}\equiv 0 \mod n$ であることを意味する。

この証明から正整数 $n$ に対して、問題3.の出力を対応させるような関数を $f:\mathbb{N}\to\mathbb{N}$ とおいたときに $f(n)\leqq n$ となることに注意すれば、 for ループが $n$ 回で足りることに注意してください。

### 発展的な課題の解説

さて、発展的な課題として残した等号成立条件 $f(n)=n$ がいつ成立するかについて考えましょう。結論を述べると以下のようになります。なお計算機で実際にいつ等号が成立するかを実験してみると、規則性に感づけるはずです。こういった計算機による証拠集めは数学において非常に有効です。ただし、実際に証明を与えることは少し乖離があります。

!!! Note "定理"

    これまでの議論と同じ記号のもと、$f(n)=n$ となるのは $n$ が $3$ のべきである、すなわちある非負整数 $k$ が存在して $n=3^k$ と書けるとき、かつそのときに限る。

??? "証明 ($n=3^k$ のとき $f(n)=n$ である)"

    以下正整数 $a,b$ に対して $b$ が $a$ で割り切れることを $a|b$ と書くことにする。$v_3:\mathbb{N}\to\mathbb{N}$ を $3$進付値、すなわち

    $$
    v_3(m)=\max\{k\geq 0:k\mbox{ は整数で }3^k|m\}
    $$

    とおく。このとき、任意の正整数 $m$ について

    $$
    v_3(R_m)=v_3(m)
    $$

    が成立する。これが言えれば、$n|R_m$ のとき $v_3(m)=v_3(R_m)\geq v_3(n)=k$ となり $m\geq 3^k$ が言えるので、$f(n)\leq n$ と合わせて $f(n)=n$ が言える。

    数学オリンピックなどで有名な [LTEの補題](https://ja.wikipedia.org/wiki/LTE%E3%81%AE%E8%A3%9C%E9%A1%8C) を仮定すれば $v_3(R_m)=m$ となることはほとんど自明だが、今回はより初等的な方法で証明を与えよう。$v_3(m)$ に対する数学的帰納法を用いる。まず $v_3(m)=0$すなわち $m$ が $3$ の倍数でないときは

    $$
    R_m\equiv\sum_{i=0}^{m-1}10^i\equiv\sum_{i=0}^{m-1}1\equiv m\not\equiv 0\mod 3
    $$

    となるので $v_3(R_m)=0$ となって示したいことが得られる。$v_3(m)\leqq\ell$ で $v_3(R_m)=v_3(m)$ が成立すると仮定して $v_3(m)=\ell+1$ の場合を考えよう。このとき、$m=3^{\ell+1}q$ と正整数 $q$ を用いて書くと、

    $$
    \begin{align*}
    v_3(R_m)&=v_3\left(\frac{10^m-1}{9}\right)\\
    &=v_3\left(\frac{(10^{3^{\ell}q}-1)(10^{2\cdot 3^{\ell}q}+10^{3^{\ell}q}+1)}{9}\right)\\
    &=v_3(10^{3^{\ell }q}-1)+v_3(10^{2\cdot 3^{\ell }q}+10^{3^{\ell }q}+1)-v_3(9)\\
    &=v_3(9R_{m/3})+v_3(10^{2\cdot 3^{\ell }q}+10^{3^{\ell }q}+1)-2
    \end{align*}
    $$

    となる。ここで、帰納法の仮定から $v_3(9R_{m/3})=2+v_3(R_{m/3})=2+v_3(m/3)=2+\ell$ となる一方、

    $$
    10^{2\cdot 3^{\ell}q}+10^{3^{\ell}q}+1\equiv 1+1+1=3\not\equiv 0\mod 9
    $$

    より $v_3(10^{2\cdot 3^{\ell}q}+10^{3^{\ell}q}+1)=1$ なので、以上をまとめて $v_3(R_m)=\ell+1=v_3(m)$ となる。ゆえに帰納法で示すことができた。

??? "証明 ($f(n)=n$ のとき $n=3^k$ なる $k$ が存在する)"

    ここでは前半の証明で用いた記号は踏襲する。
    
    非負整数 $k$ と $3$ と互いに素な整数 $q$ を用いて $n=3^kq$ と書こう。$f(n)=0$ のときは等号は成立しえないので、以下 $q$ は $2$ でも $5$ でも割れないとして良い。$f(n)=n$ ならば $q=1$ を示せばよいので、対偶をとって $q>1$ ならば $f(n)<n$ を示そう。 $m=f(n)$ とおく。 $n|R_m$ は $3^k|R_m$ かつ $q|R_m$ と同値である。
    
    前半の議論から $3^k|R_m$ は $v_3(m)\geq k$ と同値である。また、$q|R_m$ と $q|10^m-1$ は同値である。ゆえに
    
    $$
    \mathrm{ord}_q(10)=\min\{d\in\mathbb{N}:10^d\equiv 1\mod q\}
    $$
    
    とおけば、$q|R_m$ は $\mathrm{ord}_q(10)|m$ と同値になる。以上の議論から $a,b$ の最小公倍数を $\mathrm{lcm}(a,b)$ と書くとき、$n$ が $2$ でも $5$ でも割り切れない限り実は

    $$
    f(n)=\mathrm{lcm}(3^k,\mathrm{ord}_q(10))
    $$
    
    が成立する。[オイラーのトーシェント関数](https://ja.wikipedia.org/wiki/%E3%82%AA%E3%82%A4%E3%83%A9%E3%83%BC%E3%81%AE%CF%86%E9%96%A2%E6%95%B0)を $\varphi$ と書くことにすると、$q$ と $10$ は互いに素だから、よく知られたように $10^{\varphi(q)}\equiv 1\mod q$ なので、$\mathrm{ord}_q(10)|\varphi(q)$ である。[^3] $q>1$ ならば $\varphi(q)<q$ に注意すると、

    $$
    \begin{align*}
    f(n)&=\mathrm{lcm}(3^k,\mathrm{ord}_q(10))\\
    &\leqq 3^k\mathrm{ord}_q(10)\\
    &\leqq 3^k\varphi(q)\\
    &< 3^k q\\
    &=n
    \end{align*}
    $$

    となり、 $f(n)<n$ が示されたことになる。

??? "計算量的な補足"

    以上の議論から $f(n)$ を計算量的な観点から眺めてみると、$f(n)$ の計算は実質的に [離散対数問題](https://ja.wikipedia.org/wiki/%E9%9B%A2%E6%95%A3%E5%AF%BE%E6%95%B0) の特別なケースを解くことに相当し、このことから $f(n)$ を計算する多項式時間アルゴリズムは存在しないだろうということが予想されます。

[^3]: やや議論を省略しているが、一般に互いに素な整数 $a,b$ に対して、ある $d$ が存在して $\{k\in\mathbb{N}:a^k\equiv 1\mod b\}=\{nd:n\in\mathbb{N}\}$ となることが割と簡単に示せるので、これを用いています。